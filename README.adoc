// Copyright (c) 2022 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:projectid: liberty-deepdive
:page-layout: guide-multipane
:page-duration: 100 minutes
:page-releasedate: 2022-03-31
:page-essential: false
:page-description: Learn how to use Liberty to develop microservice.
:page-tags: []
:page-related-guides: []
:page-permalink: /guides/{projectid}
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/prod
:imagesdir: /img/guide/{projectid}
:source-highlighter: prettify
:page-seo-title: Implementing a microservice using Jakarta EE and MicroProfile API
:page-seo-description: A tutorial with examples on how to implement a microservice using Jakarta EE and Eclipse MicroProfile API.
:guide-author: Open Liberty
= Liberty deepdive class

[.hidden]
NOTE: This repository contains the guide documentation source. To view the guide in published form,
view it on the https://openliberty.io/guides/{projectid}.html[Open Liberty website].

Liberty is a cloud-optimized Java runtime that is fast to start up with a low memory footprint and a dev mode for quick iteration. Adding and removing features to adopt the latest open cloud-native Java API like MicroProfile and Jakarta EE are easy with Liberty. Liberty's zero migration lets you focus on what's important and not the APIs changing under you.

== What you'll learn

You will learn how to build...

== Additional prerequisites

Before you begin, Docker needs to be installed before starting the module of Presisting Data.
For installation instructions, refer to the https://docs.docker.com/get-docker/[official Docker documentation^].
You'll build and run the application in Docker containers.

Make sure to start your Docker daemon before you proceed.

///////////////////////////
// Getting started
///////////////////////////

[role='command']
include::{common-includes}/gitclone.adoc[]

== Getting started with Liberty and REST

Liberty now has an easy way to get started using the Open Liberty Starter. This tool provides a simple and quick way to get the necessary files to start building an application on Open Liberty. Through this tool you can specify your application and project name, choose a build tool from either Maven or Gradle, and pick which version of Java SE, Jakarta EE, and MicroProfile your application will use.

In this workshop, we will use the Open Liberty Starter to create the start of our application. We will use Maven as our selected build tool and will use Java SE version 17, Jakarta EE 9 and MicroProfile version 5.

To get started with this tool, visit the Getting Started page:
https://openliberty.io/start/[https://openliberty.io/start/^]

Once there, we must now enter the properties needed for our application.

Under Group specify:
`io.openliberty.deepdive`

Under Artifact specify:
`liberty-deepdive-inventory`

Under Build Tool select:
`Maven`

Under Java SE Version select:
`17`

Under Java EE/Jakarta EE Version select:
`9`

Under MicroProfile Version select:
`5`

Then select the `Generate Project` Button.
This will download the starter project as a .zip file. 

Next, unpackage the .zip file on your machine.
Move the contents of this unzipped file to within the start directory of this project.


=== Building the application:

This application is configured to be built with Maven. Every Maven-configured project contains a `pom.xml` file, which defines the project configuration, dependencies, plug-ins, and so on.

Your pom.xml file is located in the `start/liberty-deepdive-inventory` directory and is configured to include the `liberty-maven-plugin`, which allows you to install applications into Open Liberty and manage the server instances.

To begin, open a command line session and navigate to the instaled application directory. 

[role='command']
```
cd start/liberty-deepdive-inventory
```

Build the system microservice that is provided and deploy it to Open Liberty by running the Maven liberty:run goal:

[role='command']
```
mvn liberty:run
```

The `mvn` command initiates a Maven build, during which the target directory is created to store all build-related files.

The `liberty:run` argument specifies the Open Liberty `run` goal, which
starts an Open Liberty server instance in the foreground.
As part of this phase, an Open Liberty server runtime is downloaded and installed into
the `target/liberty/wlp` directory, a server instance is created and configured in the
`target/liberty/wlp/usr/servers/defaultServer` directory, and the application is
installed into that server via https://www.ibm.com/support/knowledgecenter/en/SSEQTP_liberty/com.ibm.websphere.wlp.doc/ae/rwlp_loose_applications.html[loose config^].

For more information about the Liberty Maven plug-in, see its https://github.com/WASdev/ci.maven[GitHub repository^].

When the server begins starting up, various messages display in your command-line session. Wait
for the following message, which indicates that the server startup is complete:

[source, role="no_copy"]
----
[INFO] [AUDIT] CWWKF0011I: The server defaultServer is ready to run a smarter planet.
----

When you need to stop the server, press `CTRL+C` in the command-line session where
you ran the server, or run the `liberty:stop` goal from the `start` directory in
another command-line session:

[role='command']
```
mvn liberty:stop
```


=== Starting and stopping the Open Liberty server in the background

Although you can start and stop the server in the foreground by using the Maven
`liberty:run` goal, you can also start and stop the server in the background with
the Maven `liberty:start` and `liberty:stop` goals:

[role='command']
----
mvn liberty:start
mvn liberty:stop
----


=== Updating the server configuration without restarting the server

The Open Liberty Maven plug-in includes a `dev` goal that listens for any changes in the project, 
including application source code or configuration. The Open Liberty server automatically reloads the configuration without restarting. This goal allows for quicker turnarounds and an improved developer experience.

Stop the Open Liberty server if it is running, and start it in dev mode by running the `liberty:dev` goal in the `start` directory:

[role='command']
```
mvn liberty:dev
```

Dev mode automatically picks up changes that you make to your application and allows you to run tests by pressing the `enter/return` key in the active command-line session. When you’re working on your application, rather than rerunning Maven commands, press the `enter/return` key to verify your change.



=== Developing a RESTful microservice

Inventory.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-getting-started/src/main/java/io/openliberty/deepdive/rest/Inventory.java[]
----

[role="code_command hotspot file=0", subs="quotes"]
----
#Create the `Inventory` class.#
`src/main/java/io/openliberty/deepdive/rest/Inventory.java`
----


SystemData.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-getting-started/src/main/java/io/openliberty/deepdive/rest/model/SystemData.java[]
----

[role="code_command hotspot file=1", subs="quotes"]
----
#Create the `SystemData` class.#
`src/main/java/io/openliberty/deepdive/rest/model/SystemData.java`
----


SystemResource.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-getting-started/src/main/java/io/openliberty/deepdive/rest/SystemResource.java[]
----

[role="code_command hotspot file=2", subs="quotes"]
----
#Create the `SystemResource` class.#
`src/main/java/io/openliberty/deepdive/rest/SystemResource.java`
----


RestApplication.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-getting-started/src/main/java/io/openliberty/deepdive/rest/RestApplication.java[]
----

The [hotspot=path file=2]`@Path` annotation in the `SystemResource` class indicates that this resource responds to the `/systems` path in the JAX-RS application. The [hotspot=applicationPath file=3]`@ApplicationPath` annotation in the `RestApplication` class together with the [hotspot=path file=2]`@Path` annotation in the `SystemResource` class indicates that this resource is available at the `/api/systems` path.

JAX-RS maps the HTTP methods on the URL to the methods of the class by using annotations. 
The [hotspot=getListContents file=2]`@GET` annotation on the method indicates that the method is to be called for the HTTP `GET` method. The [hotspot=producesListContents file=2]`@Produces` annotation indicates the format of the content that will be returned. The value of the [hotspot=producesListContents file=2]`@Produces` annotation will be specified in the HTTP `Content-Type` response header. For this application, a JSON structure is returned for these `Get` methods. The desired `Content-Type` for a JSON response is `application/json` with `MediaType.APPLICATION_JSON` instead of the `String` content type. Using a constant such as `MediaType.APPLICATION_JSON` is better because if there's a spelling error, a compile failure occurs.

JAX-RS supports a number of ways to marshal JSON. The JAX-RS 2.1 specification mandates JSON-Binding (JSON-B). The method body returns the result of [hotspot=getSystems file=2]`inventory.getSystems()`. Since the method is annotated with [hotspot=producesListContents file=2]`@Produces(MediaType.APPLICATION_JSON)`, JAX-RS uses JSON-B to automatically convert the returned object to JSON data in the HTTP response.


=== Running the application:

Because you started the Open Liberty server in dev mode at the beginning of the guide, all the changes were automatically picked up.

Check out the service that you created at the http://localhost:9080/inventory/api/systems URL.


== Documenting APIs

Next, we'll see how to document and filter RESTful APIs from annotations, POJOs (Plain old Java objects), and static OpenAPI files by using MicroProfile OpenAPI.

The OpenAPI specification, previously known as the Swagger specification, defines a standard interface for documenting and exposing RESTful APIs. This specification allows both humans and computers to understand or process the functionalities of services without requiring direct access to underlying source code or documentation. The MicroProfile OpenAPI specification provides a set of Java interfaces and programming models that allow Java developers to natively produce OpenAPI v3 documents from their JAX-RS applications.

The MicroProfile OpenAPI API is included in the MicroProfile dependency that is specified in your `pom.xml` file. Look for the dependency with the `microprofile` artifact ID. This dependency provides a library that allows you to use the MicroProfile OpenAPI API. The `microProfile-5.0` feature is also enabled in the `src/main/liberty/config/server.xml` file.

=== Generating the Open API document

Because the JAX-RS framework handles basic API generation for JAX-RS annotations, a skeleton OpenAPI tree can be generated from the existing inventory service. You can use this tree as a starting point and augment it with annotations and code to produce a complete OpenAPI document.

Visit the http://localhost:9080/openapi URL to see the generated OpenAPI tree. 

You can also visit the http://localhost:9080/openapi/ui URL for a more interactive view of the APIs. Click the `interactive UI` link on the welcome page.


=== Augmenting the existing JAX-RS annotations with OpenAPI annotations

Because all JAX-RS annotations are processed by default, you can augment the existing code with OpenAPI annotations without needing to rewrite portions of the OpenAPI document that are already covered by the JAX-RS framework.

SystemResource.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-openapi/src/main/java/io/openliberty/deepdive/rest/SystemResource.java[]
----

[role="code_command hotspot file=0", subs="quotes"]
----
#Update the `SystemResources` class.#
`src/main/java/io/openliberty/deepdive/rest/SystemResource.java`
----


Add OpenAPI [hotspot=addSystemAPIResponse hotspot=updateSystemAPIResponse hotspot=removeSystemAPIResponse hotspot=addSystemClientAPIResponses file=0]`@APIResponse`, [hotspot=addSystemAPIResponses hotspot=updateSystemAPIResponses hotspot=removeSystemAPIResponses hotspot=addSystemClientAPIResponse file=0]`@APIResponses`, [hotspot=listContentsAPIResponseSchema hotspot=getSystemAPIResponseSchema file=0]`@APIResponseSchema`, [hotspot=listContentsOperation hotpost=getSystemOperation hotspot=addSystemOperation hotspot=updateSystemOperation hotspot=removeSystemOperation hotspot=addSystemClientOperation file=0]`@Operation`, [hotspot=addSystemParameters hotspot=updateSystemParameters file=0]`@Parameters`, and [hotspot=getSystemParameter hotspot=addSystemParameter hotspot=updateSystemParameter hotspot=removeSystemParameter hotspot=addSystemClientParameter file=0]`@Parameter` annotations to the JAX-RS methods, [hotspot=listContents file=0]`listContents()`, [hotspot=getSystem file=0]`getSystem`, [hotspot=addSystem file=0]`addSystem`, [hotspot=updateSystem file=0]`updateSystem`, [hotspot=removeSystem file=0]`removeSystem`, and [hotspot=addSystemClient file=0]`addSystemClient`.

Note, the `@Parameter` annotation can be placed either inline or outline. We've provided examples of both within this class.

There are many OpenAPI annotations that can be utilised depending on what's best for your application and it's classes. We've broken down the ones used within this application:

[cols="35, 200", options="header"]
|===
| *Annotation*    | *Description*
| [hotspot=addSystemAPIResponse hotspot=updateSystemAPIResponse hotspot=removeSystemAPIResponse hotspot=addSystemClientAPIResponses file=0]`@APIResponse`  | Describes a single response from an API operation.
| [hotspot=addSystemAPIResponses hotspot=updateSystemAPIResponses hotspot=removeSystemAPIResponses hotspot=addSystemClientAPIResponse file=0]`@APIResponses`  | Describes multiple responses from an API operation.
| [hotspot=listContentsAPIResponseSchema hotspot=getSystemAPIResponseSchema file=0]`@APIResponseSchema` | Convenient short-hand way to specify a simple response with a Java class that could otherwise be specified using @APIResponse.
| [hotspot=listContentsOperation hotpost=getSystemOperation hotspot=addSystemOperation hotspot=updateSystemOperation hotspot=removeSystemOperation hotspot=addSystemClientOperation file=0]`@Operation`    | Describes a single API operation on a path.
| [hotspot=addSystemParameters hotspot=updateSystemParameters file=0]`@Parameters`    | Describes multiple operation parameters.
| [hotspot=getSystemParameter hotspot=addSystemParameter hotspot=updateSystemParameter hotspot=removeSystemParameter hotspot=addSystemClientParameter file=0]`@Parameter`    | Describes a single operation parameter.
|===


Since the Open Liberty server was started in development mode at the beginning of the guide, your changes were automatically picked up.
Refresh the http://localhost:9080/openapi URL to see the updated OpenAPI tree. 
The endpoints at which your JAX-RS methods are served are now more meaningful:

[source, YAML, role="no_copy"]
----
---
openapi: 3.0.3
info:
  title: Generated API
  version: "1.0"
servers:
- url: http://localhost:9080/inventory
- url: https://localhost:9443/inventory
paths:
  /api/systems:
    get:
      summary: List contents.
      description: Returns the currently stored host:properties pairs in the inventory.
      operationId: listContents
      responses:
        "200":
          description: Returns the currently stored host:properties pairs in the inventory.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/SystemData'
    post:
      summary: Add system
      description: This adds a system and its properties to the inventory list of
        systems.
      operationId: addSystem
      parameters:
      - name: heapSize
        in: query
        description: The heapSize of the system
        required: true
        schema:
          type: number
        example: foo
      - name: hostname
        in: query
        description: The hostname of the system
        required: true
        schema:
          type: string
        example: foo
      - name: javaVersion
        in: query
        description: The javaVersion of the system
        required: true
        schema:
          type: string
        example: foo
      - name: osName
        in: query
        description: The osName of the system
        required: true
        schema:
          type: string
        example: foo
      requestBody:
        content:
          application/x-www-form-urlencoded:
            schema:
              type: object
              properties:
                hostname:
                  type: string
                osName:
                  type: string
                javaVersion:
                  type: string
                heapSize:
                  format: int64
                  type: integer
      responses:
        "200":
          description: Successfully added system to inventory
        "400":
          description: Unable to add system to inventory
  /api/systems/client/{hostname}:
    post:
      summary: Add system client
      description: This adds a system client.
      operationId: addSystemClient
      parameters:
      - name: hostname
        in: path
        required: true
        schema:
          type: string
      - name: hostname
        in: query
        description: The hostname of the system
        required: true
        schema:
          type: string
        example: foo
      responses:
        "200":
          description: Successfully added system client
        "400":
          description: Unable to add system client
  /api/systems/{hostname}:
    get:
      summary: Get System
      description: Retrieves and returns the JVM system properties from the system
        service running on the particular host.
      operationId: getSystem
      parameters:
      - name: hostname
        in: path
        required: true
        schema:
          type: string
      - name: hostname
        in: query
        description: The hostname of the system
        required: true
        schema:
          type: string
        example: foo
      responses:
        "200":
          description: JVM system properties of a particular host.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/SystemData'
    put:
      summary: Update system
      description: This updates a system and its properties on the inventory list
        of systems.
      operationId: updateSystem
      parameters:
      - name: hostname
        in: path
        required: true
        schema:
          type: string
      - name: heapSize
        in: query
        description: The heapSize of the system
        required: true
        schema:
          type: number
        example: foo
      - name: hostname
        in: query
        description: The hostname of the system
        required: true
        schema:
          type: string
        example: foo
      - name: javaVersion
        in: query
        description: The javaVersion of the system
        required: true
        schema:
          type: string
        example: foo
      - name: osName
        in: query
        description: The osName of the system
        required: true
        schema:
          type: string
        example: foo
      requestBody:
        content:
          application/x-www-form-urlencoded:
            schema:
              type: object
              properties:
                osName:
                  type: string
                javaVersion:
                  type: string
                heapSize:
                  format: int64
                  type: integer
      responses:
        "200":
          description: Successfully updated system
        "400":
          description: "Unable to update system, as this system does not exist in\
            \ the inventory list"
    delete:
      summary: Remove system
      description: This removes a system and its properties from the inventory list
        of systems.
      operationId: removeSystem
      parameters:
      - name: hostname
        in: path
        required: true
        schema:
          type: string
      - name: hostname
        in: query
        description: The hostname of the system
        required: true
        schema:
          type: string
        example: foo
      responses:
        "200":
          description: Successfully deleted system from inventory
        "400":
          description: "Unable to delete system from inventory, as this system does\
            \ not exist"
components:
  schemas:
    SystemData:
      type: object
      properties:
        hostname:
          type: string
        osName:
          type: string
        javaVersion:
          type: string
        heapSize:
          format: int64
          type: integer
----


SystemData.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-openapi/src/main/java/io/openliberty/deepdive/rest/model/SystemData.java[]
----

[role='code_command hotspot file=1', subs="quotes"]
----
#Update the `SystemData` class.#
`src/main/java/io/openliberty/deepdive/rest/model/SystemData.java`
----

OpenAPI annotations can also be added to POJOs to describe what they represent. 
Currently, the OpenAPI document doesn't have a very meaningful description of the `SystemData` POJO and hence it's very difficult to tell exactly what this POJO is used for. 
To describe the`SystemData` POJO in more detail, augment the [hotspot file=1]`src/main/java/io/openliberty/deepdive/rest/model/SystemData.java` file with some OpenAPI annotations.

Add OpenAPI [hotspot=SystemDataSchema hotspot=hostnameSchema file=1]`@Schema` annotations to the [hotspot=SystemDataSchema file=1]`SystemData` class and the [hotspot=hostnameSchema file=1]`hostname` variable.


Refresh the http://localhost:9080/openapi URL to see the updated OpenAPI tree:

[source, YAML, role="no_copy"]
----
components:
  schemas:
    SystemData:
      description: POJO that represents a single inventory entry.
      required:
      - hostname
      - properties
      type: object
      properties:
        hostname:
          type: string
        properties:
          type: object
----


==  Configuring the microservice

Next, we'll look at how we can externalize and inject both static and dynamic configuration properties for microservices using MicroProfile Config.

The MicroProfile Config API is included in the MicroProfile dependency that is specified in your `pom.xml` file. Look for the dependency with the `microprofile` artifact ID. This dependency provides a library that allows you to use the MicroProfile Config API to externalize configurations for your microservices. The `microProfile-5.0` feature is also enabled in the `src/main/liberty/config/server.xml` file.

MicroProfile Config combines configuration properties from multiple sources, each known as a ConfigSource. Each ConfigSource has a specified priority, defined by its `config_ordinal` value.

A higher ordinal value means that the values taken from this ConfigSource will override values from ConfigSources with a lower ordinal value.

The following four sources are the default configuration sources:

* A `<variable name="…​" value="…​"/>` element in the server.xml file has a default ordinal of 500.

* System properties has a default ordinal of 400. (e.g. `bootstrap.properties` file)

* Environment variables have a default ordinal of 300. (e.g. `server.env` file)

* Configuration property files on the classpath have a default ordinal of 100 (e.g. `microprofile-config.properties` file)


=== Enabling configuraable ports and context root

Before we begin this next module, we first need to stop Liberty running.

To do this you can either press `CTRL+C` in the command-line session where you ran the server, or run the `liberty:stop` goal from the `start` directory in another command-line session:

[role='command']
```
mvn liberty:stop
```

So far we've been using hard-coded values to set our HTTP and HTTPS ports, as well as our context root. Now, we're going to add configuration to be able to change these values. 

server.xml
[source, xml, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-config/src/main/liberty/config/server.xml[]
----

[role='code_command hotspot file=0', subs="quotes"]
----
#Update the `server.xml` file.#
`src/main/liberty/config/server.xml`
----


Add variables for the [hotspot=httpPortVariable file=0]`HTTP` port, [hotspot=httpsPortVariable file=0]`HTTPS` port and for the [hotspot=contextRootVariable file=0]`context root` to the `server.xml` file. Change the [hotspot=editedHttpEndpoint file=0]`httpEndpoint` element to reflect the new `default.http.port` and `default.http.port` variables and change the [hotspot=editedContextRoot file=0]`contextRoot` to utilise the new `default.context.root` variable too.

pom.xml
[source, xml, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-config/pom.xml[]
----

[role='code_command hotspot file=1', subs="quotes"]
----
#Update the `pom.xml` file.#
`pom.xml`
----

Add properties for the [hotspot=httpPort file=1]`HTTP` port, [hotspot=httpsPort file=1]`HTTPS` port and the [hotspot=contextRoot file=1]`context root` to the `pom.xml` file. 

To edit this configuration, we will re-run the application using dev mode with the addition of new values for these configurable variables.

[role='command']
```
mvn liberty:dev -Ddefault.http.port=9081 -Ddefault.https.port=9445 -Ddefault.context.root=/trial
```

Now, when you want to access the application, use the following URL http://localhost:9081/trial/api/systems.

We'll now stop and restart the application to revert back to the default configuration.

[role='command']
```
mvn liberty:stop
```

[role='command']
```
mvn liberty:dev
```

=== Injecting static configuration

We'll now explore how we can make use of MicroProfile's Config API to inject static configuration into our microservices.

The MicroProfile Config API is included in the MicroProfile dependency that is specified in your `pom.xml` file. Look for the dependency with the `microprofile` artifact ID. This dependency provides a library that allows you to use the MicroProfile Config API. The `microProfile-5.0` feature is also enabled in the `src/main/liberty/config/server.xml` file.

First we need to edit the `SystemResource` class to enable us to inject static configuration into it.

SystemResource.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-config/src/main/java/io/openliberty/deepdive/rest/SystemResource.java[]
----

[role="code_command hotspot file=0", subs="quotes"]
----
#Update the `SystemResource` class.#
`src/main/java/io/openliberty/deepdive/rest/SystemResource.java`
----

The [hotspot=injectConfig file=0]`@Inject` annotation injects the client HTTPS port number directly, the injection value is static and fixed on application starting.

Edit the [hotspot=printClientPort file=0]`POST` request within the `SystemResource` class, `/inventory/api/systems/client/{hostname}`, to print out the `CLIENT_PORT` value.

Visit the following `http://localhost:9080/inventory/api/systems/client/{hostname}` to view this CLIENT_PORT value.

=== Adding microprofile-config.properties file

microprofile-config.properties
[source, text, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-config/src/main/resources/META-INF/microprofile-config.properties[]
----

[role="code_command hotspot file=0", subs="quotes"]
----
#Create the `microprofile-config.properties` file.#
`src/main/java/io/openliberty/deepdive/rest/liberty/config/microprofile-config.properties`
----

The [hotspot=ordinal file=0]`config_ordinal` variable in this properties file enables us to set the ordinal of this file and thus what other ConfigSources it could overwrite.

The [hotspot=configPort file=0]`io_openliberty_inventory_ClientPortOverwrite` variable enables the Client Port to be overwritten.

Visit the following `http://localhost:9080/inventory/api/systems/client/{hostname}` to view this edited CLIENT_PORT value.


== Persisting data

use JPA to access and persist data to a database for the microservice

== Securing RESTful APIs

secure the RESTful APIs

== Consuming the secured RESTful APIs by JWT

use JWT/jwtSso to consume/call the secured RESTful APIs 

== Adding health checks

use MicroProfile Health to report the health status of the microservice

== Providing metrics

use MicroProfile Metrics to provide metrics from the microservice

== Testing the microservice

use test containger to test the microservice

== Building the container 

develop the microservice under container environment

package the microservice

build a container for the microservice

== Deploying the microservice to Kubernetes

install Open Liberty operator to Kubernetes

deploy the microservice to Kubernetes

== Support Licensing

use WebSphere Liberty


== Great work! You're done!

You just learnt to build a microservice in Open Liberty!

include::{common-includes}/attribution.adoc[]
